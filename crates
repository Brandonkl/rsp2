#!/usr/bin/env python3
# pylint: disable=cell-var-from-loop

# This file is licensed under WTFPL 2.0.
# I honestly do not care what you do with it.

from contextlib import contextmanager
from pathlib import Path
import os
import sys
import warnings

import pytoml as toml

# See crates.d/crates.toml for what this script is all about.
#
# For TOML file modification, this script relies mostly on plain
# text searching and substitution; this is partly because I doubt
# there's any good round-trip parsers for TOML in python,
# and I hate to destroy comments and other fine details.

CARGO_TOMLS_DIR = Path('crates.d')
MASTER_CFG_PATH = Path('crates.d/crates.toml')
MASTER_USER_CFG_PATH = Path('crates.d/config.toml')
MASTER_USER_CFG_EXAMPLE_PATH = Path('crates.d/config.example.toml')
# something long enough for people to grep and find this script
INSERTION_POINT_TEXT = "#!!INSERTION POINT FOR NEW CRATES!!#"

def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description='manage Cargo.tomls in sp2')

    class no_command:
        def __init__(self, *_junk):
            pass
        def run(self, *_junk):
            parser.error("no subcommand specified")
    parser.set_defaults(klass=no_command)

    subs = parser.add_subparsers(title='subcommands')

    for klass in ALL_COMMANDS:
        sub = subs.add_parser(klass.cmd, **klass.parser_kw)
        sub.set_defaults(klass=klass)
        klass.configure(sub)

    args = parser.parse_args()
    args.klass.run(parser, args)

ALL_COMMANDS = []
def register(klass):
    ALL_COMMANDS.append(klass)
    return klass

#------------

thru = lambda f: lambda g: lambda *a, **kw: f(g(*a, **kw)) # pylint: disable=E0602

#------------

@register
class Gen:
    cmd = 'gen'
    parser_kw = dict(
        description=f'Regenerate Cargo.tomls from the source files in {CARGO_TOMLS_DIR}',
    )

    @staticmethod
    def configure(_sub):
        pass

    @staticmethod
    def run(parser, _args):

        with pushd(search_for_root(parser.error)):
            data = read_master_config(parser.error)
            user_conf = read_master_user_config(parser.error)
            crates = data.pop('crates')
            preferred_versions = data.pop('preferred-versions')

            # catch some dumb user errors before we get too committed
            for (name, path) in crates.items():

                if not path.is_dir():
                    parser.error('[crates."{}"]: "{}": no such directory'.format(name, path))

                src = root_rel_src_toml_path(name)
                if not src.is_file():  # pylint: disable=E1101
                    parser.error('{}: no such file'.format(src))

            # callbacks that generate substitutions for the line !!some-crate-name,
            # which accept keyword arguments that are documented down by where the
            # callback is called
            def gen_constant(s):
                return lambda **_ignored: s

            def gen_relpath_to(dep_name, dep_dir):
                def inner(*, cur_dir, **_ignored):
                    # Don't use Path for this because:
                    # - It has no normpath equivalent that doesn't follow links (wtf?)
                    # - Its relpath equivalent is too strict
                    rel = os.path.normpath(os.path.relpath(dep_dir, cur_dir))
                    return f'{dep_name} = {{ path = "{rel}" }}'
                return inner

            def gen_members_as_pathdeps(**_ignored):
                root = get_root_package(parser.error)
                lines = []
                for (name, path) in crates.items():
                    if name != root:
                        lines.append(f'{name} = {{ path = "{path}" }}')
                return '\n'.join(lines)

            # FIXME vvv this is waaaaaay too application-specific.
            binary_shim_pairs = get_binary_shim_pairs()
            make_binary_shims(binary_shim_pairs)
            # FIXME ^^^ this is waaaaaay too application-specific.

            # build a dash-insensitive lookup table of callbacks
            lookup_d = {
                # name = "crate-name"
                'CRATE-NAME-LINE': lambda *, cur_name, **_ignored: f'name = "{cur_name}"',

                # builtin macros
                'WORKSPACE-MEMBERS-AS-PATH-DEPS': gen_members_as_pathdeps,

                # FIXME this is waaaaaay too application-specific.
                'BINARY-SHIM-BIN-ENTRIES': macro_subst_for_binary_shims(binary_shim_pairs),

                # FIXME this is waaaaaay too application-specific.
                'NIGHTLY-FEATURE-LINE': macro_subst_for_nightly_feature(crates, parser.error),
            }
            # for defining new macros
            lookup_put = lambda k, v: lookup_d.__setitem__(canonicalize_crate(k), v)
            lookup_get = lambda k: lookup_d.get(canonicalize_crate(k))

            for (name, path) in crates.items():
                lookup_put(name, gen_relpath_to(name, path))
            for (name, version) in preferred_versions.items():
                lookup_put(name, gen_constant('{} = {}'.format(name, inline_toml(version))))

            # Make all target directories symlinks to the root package's target,
            # to help reduce duplicate build artefacts even if we are not a
            # true workspace.
            #
            # Also link together configuration directories for subcrates.
            root_package_name = get_root_package(parser.error)

            # prepare the root crate first
            if user_conf.shared_target:
                ensure_not_symlink('target')
                Path('target').mkdir(parents=True, exist_ok=True)

            if user_conf.shared_dot_idea:
                (Path('.subcrate-cfg') / '.idea').mkdir(parents=True, exist_ok=True) # pylint: disable=E1101

            if user_conf.shared_dot_vscode:
                (Path('.subcrate-cfg') / '.vscode').mkdir(parents=True, exist_ok=True) # pylint: disable=E1101

            # link the rest
            for (name, path) in crates.items():
                if name != root_package_name:
                    if user_conf.shared_target:
                        maybe_ensure_target_link('.', path)

                    if user_conf.shared_dot_idea:
                        maybe_ensure_target_link('.subcrate-cfg', path, filename='.idea')

                    if user_conf.shared_dot_vscode:
                        maybe_ensure_target_link('.subcrate-cfg', path, filename='.vscode')

            # generate modified forms of each Cargo.toml
            for (name, path) in crates.items():

                src_path = Path(root_rel_src_toml_path(name))
                dest_path = path / 'Cargo.toml'
                with open(src_path) as f:
                    lines = list(f)

                with open(dest_path, 'w') as f:
                    write = lambda *args: print(*args, file=f)
                    write("# DO NOT EDIT THIS FILE BY HAND!!")
                    write("# It has been autogenerated from", src_path)
                    write("#")
                    write("# To update it, run './crates gen' in the workspace root")
                    write()

                    for (i, line) in enumerate(lines):
                        line = line.rstrip('\n')

                        macro = line_as_macro(line)
                        if macro is None:
                            write(line)
                            continue

                        func = lookup_get(macro)
                        if func is None:
                            s = f"{src_path}:{i}: unknown macro: {format_macro(macro)}"
                            parser.error(s)

                        write(func(
                            # These are the keyword args available to callbacks:
                            # The directory for the Cargo.toml that we are generating.
                            cur_dir=path,
                            # The name of the crate whose Cargo.toml we are generating.
                            cur_name=name,
                        ))

# a makeshift toml.dumps that uses inline tables
def inline_toml(x):
    if isinstance(x, dict):
        items = ', '.join(f'{k} = {inline_toml(v)}' for (k, v) in x.items())
        return f'{{ {items} }} '
    elif isinstance(x, list):
        items = ', '.join(inline_toml(v) for v in x)
        return f'[{items}]'
    # types that only have an inline representation
    elif isinstance(x, (str, float, int, bool)):
        # I'm not 100% sure if python str() makes a valid toml str
        # so dumb dumb hack dumb hack hack dumb dumb dumb
        s = toml.dumps({'a': x}).strip()
        assert s.startswith('a')
        s = s[1:].strip()
        assert s.startswith('=')
        s = s[1:].strip()
        return s
    else:
        raise TypeError(x)

# If a line is of the form "  !!macro-name  ", get "macro-name", else None
def line_as_macro(line):
    line = line.strip()
    if line[:2] == "!!":
        return line[2:]
    return None

def format_macro(name):
    return '!!' + name

# crates are generally compared as dash-insensitive
def canonicalize_crate(crate_name):
    return crate_name.replace('_', '-')

# tries to have a crate's target symlink back to the root crate's target,
# but may fail. (no big deal)
#
# The logic here was really intended for just the target directory,
#  but 'name' can be specified to reuse this for files where the logic
#  for target is probably good enough
# (the theme is: "a symlink to a directory that an IDE is very likely
#                 to attempt to regenerate the moment it vanishes")
def maybe_ensure_target_link(root_path, crate_path, filename='target'):
    path = Path(crate_path) / filename
    dest = os.path.relpath(Path(root_path) / filename, crate_path)

    # don't remove existing links unless we have to.
    if path.is_symlink() and os.readlink(path) == str(dest):
        return

    # As soon as we destroy the existing contents, we are in a race
    #  against the RLS to recreate the directory the way WE want it.
    rm_rf(path)

    # gogogogogogogogo!!!!!!
    try: os.symlink(dest, path)
    except FileExistsError:
        # Damn, the RLS probably beat us.
        # Let it win; maybe we'll have better luck next time.
        pass

def ensure_not_symlink(path):
    if os.path.islink(path):
        os.unlink(path)

#------------

CARGO_TOML_TEMPLATE = '''
[package]
!!CRATE-NAME-LINE
version = "0.1.0"
authors = ["Michael Lamparski <diagonaldevice@gmail.com>"]

[lib]
path = "lib.rs"

[dependencies]

[features]
!!NIGHTLY-FEATURE-LINE
'''[1:]

@register
class New:
    cmd = 'new'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATENAME')
        sub.add_argument('DIR')

    @staticmethod
    def run(parser, args):

        if not is_root('.'):
            # (I'm too lazy to work out the correct relative paths
            # to be written to crates.toml)
            parser.error("The 'new' subcommand must be run from the root.")

        name = args.CRATENAME
        path = Path(args.DIR)

        if path.exists():
            parser.error(f'"{path}": path already exists')
        if (path / root_rel_src_toml_path(name)).exists():
            parser.error(f'crate "{name}" already exists')

        # Insert a line to crates.toml without destroying formatting
        # (do this now for earlier exits on error)
        with open(MASTER_CFG_PATH) as f:
            lines = list(f)
        lines = master_config_textual_add(lines, f'{name} = "{path}"\n', fail=parser.error)

        # make the directory
        path.mkdir()
        with open(root_rel_src_toml_path(name), 'w') as f:
            f.write(CARGO_TOML_TEMPLATE.format(name))
        with open(path / "Cargo.toml", 'w') as f:
            f.write(CARGO_TOML_TEMPLATE.format(name))
        with open(path / 'lib.rs', 'w') as f:
            f.write('''
#[test]
fn it_works() { }
'''[1:])

        with open_tmp(MASTER_CFG_PATH) as f:
            f.writelines(lines)

        # regenerate
        Gen.run(parser, None)

#------------

@register
class Mv:
    cmd = 'mv'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CURDIR')
        sub.add_argument('DESTDIR')

    @staticmethod
    def run(parser, args):
        do_mv_or_rm(parser, curdir=args.CURDIR, destdir=args.DESTDIR)


@register
class Rm:
    cmd = 'rm'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('DIR')

    @staticmethod
    def run(parser, args):
        do_mv_or_rm(parser, curdir=args.DIR, destdir=None)

# Shared implementation for mv and rm.
# When distdir is None, this deletes.
def do_mv_or_rm(parser, curdir, destdir):
    curdir = Path(curdir)
    if destdir is not None:
        destdir = Path(destdir)

    if not is_root('.'):
        # (I'm too lazy to work out the correct relative paths
        # to be written to crates.toml)
        cmd_name = 'rm' if destdir is None else 'mv'
        parser.error(f"The '{cmd_name}' subcommand must be run from the root.")
    root = Path('.')

    if destdir is not None and destdir.exists():
        parser.error(f'"{destdir}": path already exists')
    if not curdir.exists():
        parser.error(f'"{curdir}": path does not exist')

    crate = crate_name_from_path(curdir)

    # Edit the line in crates.toml without destroying formatting
    # (do this now for earlier exits on error)
    with open(MASTER_CFG_PATH) as f:
        lines = list(f)
    lines = master_config_textual_set_path(lines, crate, destdir, fail=parser.error)

    if destdir is None: # rm
        rm_rf(str(curdir))
        os.unlink(root / root_rel_src_toml_path(crate))
    else: # mv
        curdir.rename(destdir)

    with open_tmp(MASTER_CFG_PATH) as f:
        f.writelines(lines)

    # regenerate
    Gen.run(parser, None)

#------------

@register
class Test:
    cmd = 'test'
    parser_kw = dict(
        description=
            "Replacement for 'cargo test --all' now that this isn't a workspace."
            " You won't believe how it works."
    )

    @staticmethod
    def configure(sub):
        pass

    @staticmethod
    def run(parser, _args):
        from subprocess import Popen

        # regenerate
        Gen.run(parser, None)

        with pushd(search_for_root(parser.error)):
            # Create a replica that looks exactly like our project,
            #  except that it truly is a workspace.
            TEST_ROOT = '.secret-test-dir'
            ensure_test_replica_exists(TEST_ROOT)

            code = Popen(['cargo', 'test', '--all'], cwd=TEST_ROOT).wait()
            if code:
                sys.exit(code)

            # keep TEST_ROOT around for build artefacts

def ensure_test_replica_exists(test_root):
    import shutil
    test_root = Path(test_root)

    if not test_root.exists():
        test_root.mkdir()

    for path in map(Path, ['src', 'tests', 'examples']):
        test_path = test_root / path
        effective_path = test_root / '..' / path
        if effective_path.exists() and not test_path.exists():
            test_path.symlink_to('..' / path)

    test_cargo = test_root / 'Cargo.toml'
    shutil.copyfile('Cargo.toml', test_cargo)
    with open(test_cargo, 'a') as f:
        f.write('\n')
        f.write('[workspace]\n')

#------------

@register
class Dot:
    cmd = 'dot'
    parser_kw = dict(
        description="Show dependency graph."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('--root', action='store_true', dest='root')
        sub.add_argument('--no-root', action='store_false', dest='root')
        sub.set_defaults(root=False)

        sub.add_argument('--no-leaves', action='store_false', dest='leaves')
        sub.add_argument('--leaves', action='store_true', dest='leaves')
        sub.set_defaults(leaves=True)

    @staticmethod
    def run(parser, args):
        import matplotlib.pyplot as plt
        from networkx.drawing.nx_pydot import write_dot

        # regenerate
        Gen.run(parser, None)

        crates = get_internal_crates_and_root_rel_paths(parser.error)

        g = get_internal_dep_graph(crates, parser.error)

        if not args.root:
            g.remove_node(get_root_package(parser.error))

        if not args.leaves:
            leaves = [node for node in g if g.out_degree(node) == 0]
            for node in leaves:
                g.remove_node(node)

        write_dot(g, sys.stdout)
        plt.show()

def get_internal_dep_graph(crates, fail):
    import networkx as nx

    with pushd(search_for_root(fail)):
        g = nx.DiGraph()
        for (crate, path) in crates.items():
            with open(path / 'Cargo.toml') as f:
                d = toml.load(f)
            for dep in d['dependencies']:
                if dep in crates:
                    g.add_edge(crate, dep)
    return g

#------------

@register
class Edit:
    cmd = 'edit'
    parser_kw = dict(
        description="Edit a crate's Cargo.toml."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATE_OR_PATH', default='.',
            help="Accepts a crate name or a path to a crate directory."
            " You can also do 'edit crates' to edit crates.toml,"
            " or 'edit config' to edit config.toml.")

    @staticmethod
    def run(parser, args):
        import subprocess
        import shutil

        root = search_for_root(parser.error)

        if args.CRATE_OR_PATH == 'crates':
            toml_path = root / MASTER_CFG_PATH
        elif args.CRATE_OR_PATH == 'config':
            toml_path = root / MASTER_USER_CFG_PATH
            if not toml_path.exists():
                shutil.copyfile(root / MASTER_USER_CFG_EXAMPLE_PATH, toml_path)
                print(f"Created new config file at '{toml_path}'.", file=sys.stderr)
        else:
            if args.CRATE_OR_PATH in get_internal_crate_names(parser.error):
                crate = args.CRATE_OR_PATH
            else:
                crate = crate_name_from_path(args.CRATE_OR_PATH)
            toml_path = root / root_rel_src_toml_path(crate)

        editor = os.environ.get('EDITOR') or 'vim'
        if subprocess.run([editor, toml_path]).returncode != 0:
            print(f"Failed to edit '{toml_path}'!")
            sys.exit(1)

        # regenerate
        Gen.run(parser, None)

#------------

@register
class UnusedDeps:
    cmd = 'unused'
    parser_kw = dict(
        description="List unused external crate dependencies."
    )

    @staticmethod
    def configure(sub):
        pass

    @staticmethod
    def run(parser, _args):

        with pushd(search_for_root(parser.error)):
            data = read_master_config(parser.error)
            our_crates = list(data.pop('crates'))
            unused_deps = set(map(canonicalize_crate, data.pop('preferred-versions')))

            for crate in our_crates:
                with open(root_rel_src_toml_path(crate)) as f:
                    lines = list(f)

                # note: this set will include a None thanks to the lines
                #       that are not macros, but this is harmless.
                unused_deps -= set([canonicalize_crate(line_as_macro(x)) for x in lines])

            for dep in unused_deps:
                print(dep)


#------------

class UserConfig:
    def __init__(self, d):
        d = dict(d)
        config = d.pop('config')
        for key in d:
            warnings.warn(f"Unrecognized user-config section: {key}")

        d = dict(config)
        self.shared_target = d.pop('shared-target', True)
        self.shared_dot_idea = d.pop('shared-dot-idea', False)
        self.shared_dot_vscode = d.pop('shared-dot-vscode', False)
        for key in d:
            warnings.warn(f"Unrecognized user-config key: config.{key}")

#------------

def read_master_config(fail):
    root = search_for_root(fail)
    with open(root / MASTER_CFG_PATH) as f:
        d = toml.load(f)
    d['crates'] = {k: Path(v) for (k, v) in d['crates'].items()}
    return d

def read_master_user_config(fail):
    root = search_for_root(fail)
    try:
        with open(root / MASTER_USER_CFG_PATH) as f:
            d = toml.load(f)
        return UserConfig(d)
    except FileNotFoundError:
        return UserConfig({'config': {}})

def get_internal_crates_and_root_rel_paths(fail):
    # There used to be logic in here that branched on whether each
    # value in [crates] was a str or a dict... but I think there is
    # already other code that assumes the values are all paths?
    return read_master_config(fail)['crates']

def get_internal_crate_names(fail):
    return set(get_internal_crates_and_root_rel_paths(fail))

def get_root_package(fail):
    return read_master_config(fail)['root']

def crate_name_from_path(path):
    with open(Path(path) / "Cargo.toml") as f:
        return toml.load(f)['package']['name']

def is_root(path):
    return (Path(path) / MASTER_CFG_PATH).exists()

def search_for_root(fail):
    d = Path('.')
    for _ in range(20):
        if is_root(d):
            return d.resolve()
        d = d / '..'
    fail('Cannot find workspace root!')

# set a path for one of our crates, by plaintext search
def master_config_textual_add(lines, line, fail):
    lines = list(lines)
    stripped = [x.strip() for x in lines]
    try: i = stripped.index(INSERTION_POINT_TEXT)
    except ValueError: fail(f'''
Failed to find the new crate insertion point in '{MASTER_CFG_PATH}'
It should look like the following:
    {INSERTION_POINT_TEXT}
'''[:-1])

    lines.insert(i, line)
    return lines

# set a path for one of our crates, by plaintext search.
# 'path = None' deletes
def master_config_textual_set_path(lines, name, path, fail):
    lines = list(lines)
    name = canonicalize_crate(name)

    for (i,line) in enumerate(lines):
        if canonicalize_crate(line.strip()).startswith(name):
            # expect exactly two, paired quotes
            quotes = list(find_all_indices_of_any("\"'", line))
            if not (len(quotes) == 2 and line[quotes[0]] == line[quotes[1]]):
                fail(f"""
{MASTER_CFG_PATH}:{i}: This line looks funny, not sure how to edit it.
It should ideally look like:
    {name} = 'current/path/to/{name}'
But at least make sure there are exactly two quotes of the same style.
"""[1:])

            if path is None:
                del lines[i]
            else:
                lines[i] = f'{lines[i][:quotes[0]+1]}{path}{lines[i][quotes[1]:]}'

            return lines
    else: # pylint: disable=useless-else-on-loop
        fail(f"{MASTER_CFG_PATH}: Failed to find line for {name}.")

#------------

# FIXME this is waaaaaay too application-specific.
# Maybe .crates.d could have some simplistic plugin files or something for crap like this.
def get_binary_shim_pairs():
    with open('src/tasks/entry_points.rs') as f:
        lines = list(f)

    pairs = []
    for cur, nxt in zip(lines, lines[1:]):
        heuristic = "CRATES" # for better debugging
        cur = cur.strip()
        nxt = nxt.strip()
        if heuristic in cur:
            prefix = "// %% CRATES: binary: "
            suffix = " %%"
            assert cur.startswith(prefix)
            assert cur.endswith(suffix)
            bin = cur[len(prefix):-len(suffix)]

            prefix = "pub fn "
            suffix = "() {"
            assert nxt.startswith(prefix)
            assert nxt.endswith(suffix)
            func = nxt[len(prefix):-len(suffix)]

            pairs.append((bin, func))

    return sorted(pairs)

def make_binary_shims(pairs):
    shims_dir = Path("src/binary-shims")
    shims_dir.mkdir(exist_ok = True)

    for (bin, func) in pairs:
        with open(shims_dir / f"{bin}.rs", mode='w') as f:
            print(f"""\
extern crate rsp2_tasks;

fn main() {{
    ::rsp2_tasks::entry_points::{func}();
}}
""", end='', file=f)


def macro_subst_for_binary_shims(pairs):
    def gen(**_ignored):
        entries = []
        for (bin, func) in pairs:
            lines = [
                f"[[bin]]\n",
                f'name = "{bin}"\n',
                f'path = "src/binary-shims/{bin}.rs"\n',
            ]
            entries.append(''.join(lines))
        return '\n'.join(entries)
    return gen

def macro_subst_for_nightly_feature(crates, fail):
    g = get_internal_dep_graph(crates, fail)
    def gen(*, cur_name, **_ignored):
        deps = list(g.edge[cur_name])
        def recursive_feature_line(feature, base_list=()):
            toml_strs = [f'"{f}"' for f in base_list]
            toml_strs += sorted([f'"{d}/{feature}"' for d in deps])
            toml_list = '[' + ', '.join(toml_strs) + ']'
            return f"{feature} = {toml_list}"
        nightly = recursive_feature_line("nightly", ['beta'])
        beta = recursive_feature_line("beta")
        return f'{nightly}\n{beta}'
    return gen

#------------

def root_rel_src_toml_path(crate_name):
    return Path(CARGO_TOMLS_DIR) / f'{crate_name}.Cargo.toml'

# Variant of open(path, 'w') that writes to a temp file,
# then overwrites the requested file only once the context manager
# is exited without an exception
@contextmanager
def open_tmp(path, mode='w'):
    import tempfile
    with tempfile.NamedTemporaryFile(mode=mode, delete=False) as f:
        try: yield f
        except:
            # THIS NEVER HAPPENED
            os.unlink(f.name)
            raise
        f.flush()

    # exiting the 'with' closes (but doesn't delete) the temp file

    # Make the new file official.
    #
    # Writing Cargo.toml seems to cause rebuilds of any crate
    # that has a build.rs, so try to avoid it if we can.
    replace_if_different(path, f.name)

@contextmanager
def pushd(path):
    old = os.path.abspath('.')
    os.chdir(path)
    try: yield None
    finally: os.chdir(old)

def replace_if_different(current, candidate):
    import shutil
    with open(current) as f:
        a = f.read()
    with open(candidate) as f:
        b = f.read()

    if a != b:
        shutil.move(candidate, current)
    else:
        os.unlink(candidate)

def find_all_indices_of_any(needles, haystack):
    needles = set(needles)
    for (i, x) in enumerate(haystack):
        if x in needles:
            yield i

def rm_rf(path):
    import shutil
    path = Path(path)
    try:
        # note: cannot call rmtree on a symlink because lolidunno
        if path.is_dir() and not path.is_symlink():
            shutil.rmtree(path)
        else:
            os.unlink(path)
    except FileNotFoundError:
        pass

iife = lambda f: f()

#------------

if __name__ == '__main__':
    main()
