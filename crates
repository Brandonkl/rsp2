#!/usr/bin/env python3

# This file is licensed under WTFPL 2.0.
# I honestly do not care what you do with it.

import pytoml as toml
import os

# See crates.d/crates.toml for what this script is all about.
#
# For TOML file modification, this script relies mostly on plain
# text searching and substitution; this is partly because I doubt
# there's any good round-trip parsers for TOML in python,
# and I hate to destroy comments and other fine details.

MASTER_CFG_PATH = 'crates.d/crates.toml'
CARGO_TOMLS_DIR = 'crates.d'
# something long enough for people to grep and find this script
INSERTION_POINT_TEXT = "#!!INSERTION POINT FOR NEW CRATES!!#"

def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description='manage Cargo.tomls in sp2')

    def no_command(*junk):
        parser.error("no subcommand specified")
    parser.set_defaults(cmd=no_command)

    subs = parser.add_subparsers(title='subcommands')
    sub = subs.add_parser('gen',
        description=f'Regenerate Cargo.tomls from the source files in ./{CARGO_TOMLS_DIR}')
    sub.set_defaults(cmd=gen__main)

    sub = subs.add_parser('new')
    sub.add_argument('CRATENAME')
    sub.add_argument('DIR')
    sub.set_defaults(cmd=new__main)

    sub = subs.add_parser('mv')
    sub.add_argument('CURDIR')
    sub.add_argument('DESTDIR')
    sub.set_defaults(cmd=mv__main)


    args = parser.parse_args()
    args.cmd(parser, args)

#------------

def gen__main(parser, args):
    data = read_master_config()
    crates = data.pop('crates')
    preferred_versions = data.pop('preferred-versions')

    # catch some dumb user errors before we get too committed
    for (name, path) in crates.items():
        if not os.path.isdir(path):
            parser.error('[crates."{}"]: "{}": no such directory'.format(name, path))

        src = src_toml_path(name)
        if not os.path.isfile(src):
            parser.error('{}: no such file'.format(src))

    # callbacks that generate substitutions for the line !!some-crate-name,
    # which accept the current Cargo.toml's directory as an argument
    def gen_constant(s):
        return lambda _: s

    def gen_relpath_to(crate_name, dep_dir):
        from os.path import normpath, relpath
        def inner(d):
            rel = normpath(relpath(dep_dir, start=d))
            return f'{crate_name} = {{ path = "{rel}" }}'
        return inner

    def gen_members_as_pathdeps(_):
        lines = []
        for (name, path) in crates.items():
            if path != ".":
                lines.append(f'{name} = {{ path = "{path}" }}')
        return '\n'.join(lines)

    # build a dash-insensitive lookup table of callbacks
    lookup_d = {
        'WORKSPACE-MEMBERS-AS-PATH-DEPS': gen_members_as_pathdeps,
    }
    lookup_put = lambda k, v: lookup_d.__setitem__(k.replace('_', '-'), v)
    lookup_get = lambda k: lookup_d.get(k.replace('_', '-'))

    for (name, path) in crates.items():
        lookup_put(name, gen_relpath_to(name, path))
    for (name, version) in preferred_versions.items():
        lookup_put(name, gen_constant('{} = {}'.format(name, inline_toml(version))))

    # generate modified forms of each Cargo.toml
    for (name, path) in crates.items():
        src_path = os.path.join(src_toml_path(name))
        dest_path = os.path.join(path, 'Cargo.toml')

        with open(src_path) as f:
            lines = list(f)

        with open(dest_path, 'w') as f:
            write = lambda *args: print(*args, file=f)
            write("# DO NOT EDIT THIS FILE BY HAND!!")
            write("# It has been autogenerated from", src_path)
            write("#")
            write("# To update it, run './crates gen' in the workspace root")
            write()

            for (i, line) in enumerate(lines):
                line = line.rstrip('\n')

                macro = line_as_macro(line)
                if macro is None:
                    write(line)
                    continue

                func = lookup_get(macro)
                if func is None:
                    s = f"{src_path}:{i}: unknown macro: {format_macro(macro)}"
                    parser.error(s)

                write(func(path))

# a makeshift toml.dumps that uses inline tables
def inline_toml(x):
    if isinstance(x, dict):
        items = ', '.join(f'{k} = {inline_toml(v)}' for (k, v) in x.items())
        return f'{{ {items} }} '
    elif isinstance(x, list):
        items = ', '.join(inline_toml(v) for v in x)
        return f'[{items}]'
    # types that only have an inline representation
    elif isinstance(x, (str, float, int, bool)):
        # I'm not 100% sure if python str() makes a valid toml str
        # so dumb dumb hack dumb hack hack dumb dumb dumb
        s = toml.dumps({'a': x}).strip()
        assert s.startswith('a')
        s = s[1:].strip()
        assert s.startswith('=')
        s = s[1:].strip()
        return s
    else:
        raise TypeError(x)

# If a line is of the form "  !!macro-name  ", get "macro-name", else None
def line_as_macro(line):
    line = line.strip()
    if line[:2] == "!!":
        return line[2:]
    return None

def format_macro(name):
    return '!!' + name

#------------

CARGO_TOML_TEMPLATE = '''
[package]
name = "{}"
version = "0.1.0"
authors = ["Michael Lamparski <diagonaldevice@gmail.com>"]

[lib]
path = "lib.rs"

[dependencies]
'''[1:]

def new__main(parser, args):
    name = args.CRATENAME
    path = args.DIR
    if os.path.exists(path):
        parser.error(f'"{path}": path already exists')
    if os.path.exists(src_toml_path(name)):
        parser.error(f'crate "{name}" already exists')

    # Insert a line to crates.toml without destroying formatting
    # (do this now for earlier exits on error)
    with open(MASTER_CFG_PATH) as f:
        lines = list(f)
    lines = master_config_textual_add(lines, f'{name} = "{path}"\n', fail=parser.error)

    # make the directory
    os.mkdir(path)
    with open(src_toml_path(name), 'w') as f:
        f.write(CARGO_TOML_TEMPLATE.format(name))
    with open(os.path.join(path, "Cargo.toml"), 'w') as f:
        f.write(CARGO_TOML_TEMPLATE.format(name))
    with open(os.path.join(path, 'lib.rs'), 'w') as f:
        f.write('''
#[test]
fn it_works() { }
'''[1:])

    with open_tmp(MASTER_CFG_PATH) as f:
        f.writelines(lines)

    # regenerate
    gen__main(parser, None)

#------------

def mv__main(parser, args):
    curdir = args.CURDIR
    destdir = args.DESTDIR
    if os.path.exists(destdir):
        parser.error(f'"{destdir}": path already exists')
    if not os.path.exists(curdir):
        parser.error(f'"{curdir}": path does not exist')

    with open(os.path.join(curdir, "Cargo.toml")) as f:
        crate = toml.load(f)['package']['name']

    # Edit the line in crates.toml without destroying formatting
    # (do this now for earlier exits on error)
    with open(MASTER_CFG_PATH) as f:
        lines = list(f)
    lines = master_config_textual_set_path(lines, crate, destdir, fail=parser.error)

    # move the directory
    os.rename(curdir, destdir)

    with open_tmp(MASTER_CFG_PATH) as f:
        f.writelines(lines)

    # regenerate
    gen__main(parser, None)

#------------

def read_master_config():
    with open(MASTER_CFG_PATH) as f:
        return toml.load(f)

# set a path for one of our crates, by plaintext search
def master_config_textual_add(lines, line, fail):
    lines = list(lines)
    stripped = [x.strip() for x in lines]
    try: i = stripped.index(INSERTION_POINT_TEXT)
    except: fail(f'''
Failed to find the new crate insertion point in '{MASTER_CFG_PATH}'
It should look like the following:
    {INSERTION_POINT_TEXT}
'''[:-1])

    lines.insert(i, line)
    return lines

# set a path for one of our crates, by plaintext search
def master_config_textual_set_path(lines, name, path, fail):
    lines = list(lines)
    name = name.replace('_', '-')
    stripped = [x.strip() for x in lines]
    for (i,line) in enumerate(lines):
        if line.strip().replace('_', '-').startswith(name):
            # expect exactly two, paired quotes
            quotes = list(find_all_indices_of_any("\"'", line))
            if not (len(quotes) == 2 and line[quotes[0]] == line[quotes[1]]):
                fail(f"""
{MASTER_CFG_PATH}:{i}: This line looks funny, not sure how to edit it.
It should ideally look like:
    {name} = 'current/path/to/{name}'
But at least make sure there are exactly two quotes of the same style.
"""[1:])

            lines[i] = lines[i][:quotes[0]+1] + path + lines[i][quotes[1]:]
            return lines
    else:
        fail(f"{MASTER_CFG_PATH}: Failed to find line for {name}.")

#------------

def src_toml_path(crate_name):
    return os.path.join(CARGO_TOMLS_DIR, f'{crate_name}.Cargo.toml')

from contextlib import contextmanager

# Variant of open(path, 'w') that writes to a temp file,
# then overwrites the requested file only once the context manager
# is exited without an exception
@contextmanager
def open_tmp(path, mode='w'):
    import tempfile
    import shutil
    with tempfile.NamedTemporaryFile(mode=mode, delete=False) as f:
        try: yield f
        except:
            # THIS NEVER HAPPENED
            import os
            os.unlink(f.name)
            raise
    # exiting the 'with' closes (but doesn't delete) the temp file

    shutil.move(f.name, path)

def find_all_indices_of_any(needles, haystack):
    needles = set(needles)
    for (i, x) in enumerate(haystack):
        if x in needles:
            yield i

iife = lambda f: f()

#------------

if __name__ == '__main__':
    main()
