#!/usr/bin/env python3
# pylint: disable=cell-var-from-loop

# This file is licensed under WTFPL 2.0.
# I honestly do not care what you do with it.

from contextlib import contextmanager
from pathlib import Path
from argparse import ArgumentParser
import os
import sys
import warnings

import pytoml as toml

# See crates.d/crates.toml for what this script is all about.
#
# For TOML file modification, this script relies mostly on plain
# text searching and substitution; this is partly because I doubt
# there's any good round-trip parsers for TOML in python,
# and I hate to destroy comments and other fine details.

CARGO_TOMLS_DIR = Path('crates.d')
MASTER_CFG_PATH = Path('crates.d/crates.toml')
MASTER_USER_CFG_PATH = Path('crates.d/config.toml')
MASTER_USER_CFG_EXAMPLE_PATH = Path('crates.d/config.example.toml')
# something long enough for people to grep and find this script
INSERTION_POINT_TEXT = "#!!INSERTION POINT FOR NEW CRATES!!#"

def main():
    parser = ArgumentParser(description='manage Cargo.tomls in sp2')

    class no_command:
        def __init__(self, *_junk):
            pass
        def run(self, *_junk):
            parser.error("no subcommand specified")
    parser.set_defaults(klass=no_command)

    subs = parser.add_subparsers(title='subcommands')

    for klass in ALL_COMMANDS:
        sub = subs.add_parser(klass.cmd, **klass.parser_kw)
        sub.set_defaults(klass=klass)
        klass.configure(sub)

    args = parser.parse_args()
    args.klass.run(parser, args)

ALL_COMMANDS = []
def register(klass):
    ALL_COMMANDS.append(klass)
    return klass

#------------

thru = lambda f: lambda g: lambda *a, **kw: f(g(*a, **kw)) # pylint: disable=E0602

#------------

KIND_SPECIAL = object()
KIND_INTERNAL_DEP = object()
KIND_EXTERNAL_DEP = object()

@register
class Gen:
    cmd = 'gen'
    parser_kw = dict(
        description=f'Regenerate Cargo.tomls from the source files in {CARGO_TOMLS_DIR}',
    )

    @staticmethod
    def configure(sub):
        sub.add_argument(
            '--force-workspace', action='store_true',
            help='temporarily override the simulated-workspace setting to prevent '
                 'undue changes that would be checked into VCS')

    @staticmethod
    def run(parser, args):
        Gen._do_it(args, parser.error)

    # several other commands invoke 'gen'.  This is kind of a dumb
    # hack to allow them to do so.
    @staticmethod
    def run_like_function(fail):
        # HACK - get the default arguments as an argparse.Namespace
        p = ArgumentParser()
        Gen.configure(p)
        default_args = p.parse_args([])
        Gen._do_it(default_args, fail)

    @staticmethod
    def _do_it(args, fail):

        with pushd(search_for_root(fail)):
            data = read_master_config(fail)
            user_conf = read_master_user_config(fail)
            crates = data.pop('crates')

            # catch some dumb user errors before we get too committed
            for (name, path) in crates.items():

                if not path.is_dir():
                    fail('[crates."{}"]: "{}": no such directory'.format(name, path))

                src = root_rel_src_toml_path(name)
                if not src.is_file():  # pylint: disable=E1101
                    fail('{}: no such file'.format(src))

            # FIXME vvv this is waaaaaay too application-specific.
            binary_shim_pairs = get_binary_shim_pairs()
            make_binary_shims(binary_shim_pairs)
            # FIXME ^^^ this is waaaaaay too application-specific.

            lookup_get = make_callback_lookup(args.force_workspace, fail)

            if user_conf.simulated_workspace.enabled:
                simulated_workspace_gen_symlinks(crates, user_conf.simulated_workspace, fail)

            # generate modified forms of each Cargo.toml
            for (name, path) in crates.items():

                src_path = Path(root_rel_src_toml_path(name))
                dest_path = path / 'Cargo.toml'
                with open(src_path) as f:
                    lines = list(f)

                with open(dest_path, 'w') as f:
                    write = lambda *args: print(*args, file=f)
                    write("# DO NOT EDIT THIS FILE BY HAND!!")
                    write("# It has been autogenerated from", src_path)
                    write("#")
                    write("# To update it, run './crates gen' in the workspace root")
                    write()

                    for (i, line) in enumerate(lines):
                        line = line.rstrip('\n')

                        macro = line_as_macro(line)
                        if macro is None:
                            write(line)
                            continue

                        tup = lookup_get(macro)
                        if tup is None:
                            s = f"{src_path}:{i}: unknown macro: {format_macro(macro)}"
                            fail(s)
                        (_kind, func) = tup

                        write(func(
                            # These are the keyword args available to callbacks:
                            # The directory for the Cargo.toml that we are generating.
                            cur_dir=path,
                            # The name of the crate whose Cargo.toml we are generating.
                            cur_name=name,
                        ))

def make_callback_lookup(force_workspace, fail):
    with pushd(search_for_root(fail)):
        data = read_master_config(fail)
        crates = data.pop('crates')
        preferred_versions = data.pop('preferred-versions')
        user_conf = read_master_user_config(fail)

        # callbacks that generate substitutions for the line !!some-crate-name,
        # which accept keyword arguments that are documented down by where the
        # callback is called
        def gen_constant(s):
            return lambda **_ignored: s

        def gen_relpath_to(dep_name, dep_dir):
            def inner(*, cur_dir, **_ignored):
                # Don't use Path for this because:
                # - It has no normpath equivalent that doesn't follow links (wtf?)
                # - Its relpath equivalent is too strict
                rel = os.path.normpath(os.path.relpath(dep_dir, cur_dir))
                return f'{dep_name} = {{ path = "{rel}" }}'
            return inner

        def gen_members_as_pathdeps(**_ignored):
            root = get_root_package(fail)
            lines = []
            for (name, path) in crates.items():
                if name != root:
                    lines.append(f'{name} = {{ path = "{path}" }}')
            return '\n'.join(lines)

        def maybe_gen_workspace_line(**_ignored):
            # This is unfortunate. The Cargo.toml files should not depend on
            # config, but there is no other way to disable a workspace.
            if user_conf.simulated_workspace.enabled and not force_workspace:
                return '''
# !!! CAUTION !!!
# The workspace table has been removed for the 'simulated-workspace'
# feature of 'crates'. Please do not check this into VCS!!!
#
# To correct it, do the following to temporarily override the
# simulated-workspace setting before committing:
#
#      ./crates gen --force-workspace
#
#[workspace]
                '''.strip()
            else:
                return '[workspace]'

        binary_shim_pairs = get_binary_shim_pairs()

        # for defining new macros
        lookup_put = lambda k, v: lookup_d.__setitem__(canonicalize_crate(k), v)
        lookup_get = lambda k: lookup_d.get(canonicalize_crate(k))

        # build a dash-insensitive lookup table of callbacks
        lookup_d = {
            # name = "crate-name"
            'CRATE-NAME-LINE': (KIND_SPECIAL, lambda *, cur_name, **_ignored: f'name = "{cur_name}"'),

            # generates all lines for our own crates in the root crate's dependencies
            'WORKSPACE-MEMBERS-AS-PATH-DEPS': (KIND_SPECIAL, gen_members_as_pathdeps),

            # [workspace].  Or not.
            'MAYBE-ITS-A-WORKSPACE': (KIND_SPECIAL, maybe_gen_workspace_line),

            # FIXME this is waaaaaay too application-specific.
            'BINARY-SHIM-BIN-ENTRIES': (KIND_SPECIAL, macro_subst_for_binary_shims(binary_shim_pairs)),

            # FIXME this is waaaaaay too application-specific.
            'NIGHTLY-FEATURE-LINE': (KIND_SPECIAL, macro_subst_for_nightly_feature(lookup_get, crates, fail)),
        }

        for (name, path) in crates.items():
            lookup_put(name, (KIND_INTERNAL_DEP, gen_relpath_to(name, path)))
        for (name, version) in preferred_versions.items():
            lookup_put(name, (KIND_EXTERNAL_DEP, gen_constant('{} = {}'.format(name, inline_toml(version)))))
    return lookup_get

# a makeshift toml.dumps that uses inline tables
def inline_toml(x):
    if isinstance(x, dict):
        items = ', '.join(f'{k} = {inline_toml(v)}' for (k, v) in x.items())
        return f'{{ {items} }} '
    elif isinstance(x, list):
        items = ', '.join(inline_toml(v) for v in x)
        return f'[{items}]'
    # types that only have an inline representation
    elif isinstance(x, (str, float, int, bool)):
        # I'm not 100% sure if python str() makes a valid toml str
        # so dumb dumb hack dumb hack hack dumb dumb dumb
        s = toml.dumps({'a': x}).strip()
        assert s.startswith('a')
        s = s[1:].strip()
        assert s.startswith('=')
        s = s[1:].strip()
        return s
    else:
        raise TypeError(x)

# If a line is of the form "  !!macro-name  ", get "macro-name", else None
def line_as_macro(line):
    line = line.strip()
    if line[:2] == "!!":
        return line[2:]
    return None

def format_macro(name):
    return '!!' + name

# crates are generally compared as dash-insensitive
def canonicalize_crate(crate_name):
    return crate_name.replace('_', '-')

# For simulated workspaces, make all target directories symlinks to
# the root package's target, to help reduce duplicate build
# artefacts even if we are not a true workspace.
#
# Also link together configuration directories for subcrates.
def simulated_workspace_gen_symlinks(crates, conf, fail):
    root_package_name = get_root_package(fail)

    # prepare the root crate first
    if conf.shared_target:
        ensure_not_symlink('target')
        Path('target').mkdir(parents=True, exist_ok=True)

    if conf.shared_dot_idea:
        (Path('.subcrate-cfg') / '.idea').mkdir(parents=True, exist_ok=True) # pylint: disable=E1101

    if conf.shared_dot_vscode:
        (Path('.subcrate-cfg') / '.vscode').mkdir(parents=True, exist_ok=True) # pylint: disable=E1101

    # link the rest
    for (name, path) in crates.items():
        if name != root_package_name:
            if conf.shared_target:
                maybe_ensure_target_link('.', path)

            if conf.shared_dot_idea:
                maybe_ensure_target_link('.subcrate-cfg', path, filename='.idea')

            if conf.shared_dot_vscode:
                maybe_ensure_target_link('.subcrate-cfg', path, filename='.vscode')

# tries to have a crate's target symlink back to the root crate's target,
# but may fail. (no big deal)
#
# The logic here was really intended for just the target directory,
#  but 'name' can be specified to reuse this for files where the logic
#  for target is probably good enough
# (the theme is: "a symlink to a directory that an IDE is very likely
#                 to attempt to regenerate the moment it vanishes")
def maybe_ensure_target_link(root_path, crate_path, filename='target'):
    path = Path(crate_path) / filename
    dest = os.path.relpath(Path(root_path) / filename, crate_path)

    # don't remove existing links unless we have to.
    if path.is_symlink() and readlink(path) == str(dest):
        return

    # As soon as we destroy the existing contents, we are in a race
    #  against the RLS to recreate the directory the way WE want it.
    rm_rf(path)

    # gogogogogogogogo!!!!!!
    try: symlink(dest, path)
    except FileExistsError:
        # Damn, the RLS probably beat us.
        # Let it win; maybe we'll have better luck next time.
        pass

def ensure_not_symlink(path):
    if os.path.islink(path):
        os.unlink(path)

#------------

CARGO_TOML_TEMPLATE = '''
[package]
!!CRATE-NAME-LINE
version = "0.1.0"
authors = ["Michael Lamparski <diagonaldevice@gmail.com>"]

[lib]
path = "lib.rs"

[dependencies]

[features]
!!NIGHTLY-FEATURE-LINE
'''[1:]

@register
class New:
    cmd = 'new'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATENAME')
        sub.add_argument('DIR')

    @staticmethod
    def run(parser, args):

        if not is_root('.'):
            # (I'm too lazy to work out the correct relative paths
            # to be written to crates.toml)
            parser.error("The 'new' subcommand must be run from the root.")

        name = args.CRATENAME
        path = Path(args.DIR)

        if path.exists():
            parser.error(f'"{path}": path already exists')
        if (path / root_rel_src_toml_path(name)).exists():
            parser.error(f'crate "{name}" already exists')

        # Insert a line to crates.toml without destroying formatting
        # (do this now for earlier exits on error)
        with open(MASTER_CFG_PATH) as f:
            lines = list(f)
        lines = master_config_textual_add(lines, f'{name} = "{path}"\n', fail=parser.error)

        # make the directory
        path.mkdir()
        with open(root_rel_src_toml_path(name), 'w') as f:
            f.write(CARGO_TOML_TEMPLATE.format(name))
        with open(path / 'lib.rs', 'w') as f:
            f.write('''
#[test]
fn it_works() { }
'''[1:])

        with open_tmp(MASTER_CFG_PATH) as f:
            f.writelines(lines)

        # regenerate
        Gen.run_like_function(parser.error)

#------------

@register
class Mv:
    cmd = 'mv'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CURDIR')
        sub.add_argument('DESTDIR')

    @staticmethod
    def run(parser, args):
        do_mv_or_rm(parser, curdir=args.CURDIR, destdir=args.DESTDIR)


@register
class Rm:
    cmd = 'rm'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('DIR')

    @staticmethod
    def run(parser, args):
        do_mv_or_rm(parser, curdir=args.DIR, destdir=None)

# Shared implementation for mv and rm.
# When distdir is None, this deletes.
def do_mv_or_rm(parser, curdir, destdir):
    curdir = Path(curdir)
    if destdir is not None:
        destdir = Path(destdir)

    if not is_root('.'):
        # (I'm too lazy to work out the correct relative paths
        # to be written to crates.toml)
        cmd_name = 'rm' if destdir is None else 'mv'
        parser.error(f"The '{cmd_name}' subcommand must be run from the root.")
    root = Path('.')

    if destdir is not None and destdir.exists():
        parser.error(f'"{destdir}": path already exists')
    if not curdir.exists():
        parser.error(f'"{curdir}": path does not exist')

    crate = crate_name_from_path(curdir)

    # Edit the line in crates.toml without destroying formatting
    # (do this now for earlier exits on error)
    with open(MASTER_CFG_PATH) as f:
        lines = list(f)
    lines = master_config_textual_set_path(lines, crate, destdir, fail=parser.error)

    if destdir is None: # rm
        rm_rf(str(curdir))
        unlink(root / root_rel_src_toml_path(crate))
    else: # mv
        curdir.rename(destdir)

    with open_tmp(MASTER_CFG_PATH) as f:
        f.writelines(lines)

    # regenerate
    Gen.run_like_function(parser.error)

#------------

@register
class Test:
    cmd = 'test'
    parser_kw = dict(
        description=
            "Replacement for 'cargo test --all' when the 'simulated-workspace'"
            " option is enabled. You won't believe how it works."
    )

    @staticmethod
    def configure(sub):
        pass

    @staticmethod
    def run(parser, _args):
        from subprocess import Popen

        # regenerate
        Gen.run_like_function(parser.error)

        def do_cargo_test_all(**kw):
            code = Popen(['cargo', 'test', '--all'], **kw).wait()
            if code:
                sys.exit(code)

        user_config = read_master_user_config(parser.error)
        with pushd(search_for_root(parser.error)):
            if user_config.simulated_workspace.enabled:
                # do the insane thing

                # Create a replica that looks exactly like our project,
                #  except that it truly is a workspace.
                TEST_ROOT = '.secret-test-dir'
                simulated_workspace_ensure_test_replica_exists(TEST_ROOT)
                do_cargo_test_all(cwd=TEST_ROOT)

                # keep TEST_ROOT around for build artefacts
            else:
                # do something reasonable instead.
                do_cargo_test_all()

def simulated_workspace_ensure_test_replica_exists(test_root):
    import shutil
    test_root = Path(test_root)

    if not test_root.exists():
        test_root.mkdir()

    for path in map(Path, ['src', 'tests', 'examples']):
        test_path = test_root / path
        effective_path = test_root / '..' / path
        if effective_path.exists() and not test_path.exists():
            test_path.symlink_to('..' / path)

    test_cargo = test_root / 'Cargo.toml'
    shutil.copyfile('Cargo.toml', test_cargo)
    with open(test_cargo, 'a') as f:
        f.write('\n')
        f.write('[workspace]\n')

#------------

@register
class Dot:
    cmd = 'dot'
    parser_kw = dict(
        description="Show dependency graph."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('--root', action='store_true', dest='root')
        sub.add_argument('--no-root', action='store_false', dest='root')
        sub.set_defaults(root=False)

        sub.add_argument('--no-leaves', action='store_false', dest='leaves')
        sub.add_argument('--leaves', action='store_true', dest='leaves')
        sub.set_defaults(leaves=True)

    @staticmethod
    def run(parser, args):
        import matplotlib.pyplot as plt
        from networkx.drawing.nx_pydot import write_dot

        # regenerate
        Gen.run_like_function(parser.error)

        crates = get_internal_crates_and_root_rel_paths(parser.error)

        g = get_internal_dep_graph(crates, parser.error)

        if not args.root:
            g.remove_node(get_root_package(parser.error))

        if not args.leaves:
            leaves = [node for node in g if g.out_degree(node) == 0]
            for node in leaves:
                g.remove_node(node)

        write_dot(g, sys.stdout)
        plt.show()

def get_internal_dep_graph(crates, fail):
    import networkx as nx

    with pushd(search_for_root(fail)):
        g = nx.DiGraph()
        for (crate, path) in crates.items():
            with open(path / 'Cargo.toml') as f:
                d = toml.load(f)
            for dep in d['dependencies']:
                if dep in crates:
                    g.add_edge(crate, dep)
    return g

#------------

@register
class Edit:
    cmd = 'edit'
    parser_kw = dict(
        description="Edit a crate's Cargo.toml."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATE_OR_PATH', default='.',
            help="Accepts a crate name or a path to a crate directory."
            " You can also do 'edit crates' to edit crates.toml,"
            " or 'edit config' to edit config.toml.")

    @staticmethod
    def run(parser, args):
        import subprocess
        import shutil

        root = search_for_root(parser.error)

        if args.CRATE_OR_PATH == 'crates':
            toml_path = root / MASTER_CFG_PATH
        elif args.CRATE_OR_PATH == 'config':
            toml_path = root / MASTER_USER_CFG_PATH
            if not toml_path.exists():
                shutil.copyfile(root / MASTER_USER_CFG_EXAMPLE_PATH, toml_path)
                print(f"Created new config file at '{toml_path}'.", file=sys.stderr)
        else:
            if args.CRATE_OR_PATH in get_internal_crate_names(parser.error):
                crate = args.CRATE_OR_PATH
            else:
                crate = crate_name_from_path(args.CRATE_OR_PATH)
            toml_path = root / root_rel_src_toml_path(crate)

        editor = os.environ.get('EDITOR') or 'vim'
        if subprocess.run([editor, toml_path]).returncode != 0:
            print(f"Failed to edit '{toml_path}'!")
            sys.exit(1)

        # regenerate
        Gen.run_like_function(parser.error)

#------------

@register
class UnusedDeps:
    cmd = 'unused'
    parser_kw = dict(
        description="List unused external crate dependencies."
    )

    @staticmethod
    def configure(sub):
        pass

    @staticmethod
    def run(parser, _args):

        with pushd(search_for_root(parser.error)):
            data = read_master_config(parser.error)
            our_crates = list(data.pop('crates'))
            unused_deps = set(map(canonicalize_crate, data.pop('preferred-versions')))

            for crate in our_crates:
                with open(root_rel_src_toml_path(crate)) as f:
                    lines = list(f)

                # note: this set will include a None thanks to the lines
                #       that are not macros, but this is harmless.
                unused_deps -= set([canonicalize_crate(line_as_macro(x)) for x in lines])

            for dep in unused_deps:
                print(dep)


#------------

class UserConfig:
    def __init__(self, d):
        d = dict(d)
        simulated_workspace = d.pop('simulated-workspace')
        for key in d:
            warnings.warn(f"Unrecognized user-config section: {key}")

        self.simulated_workspace = CfgSimulatedWorkspace(simulated_workspace)

class CfgSimulatedWorkspace:
    def __init__(self, d):
        d = dict(d)
        self.enabled = d.pop('enable', False)
        self.shared_target = d.pop('shared-target', True)
        self.shared_dot_idea = d.pop('shared-dot-idea', True)
        self.shared_dot_vscode = d.pop('shared-dot-vscode', False)
        for key in d:
            warnings.warn(f'Unrecognized user-config key: simulated-workspace.{key}')

#------------

def read_master_config(fail):
    root = search_for_root(fail)
    with open(root / MASTER_CFG_PATH) as f:
        d = toml.load(f)
    d['crates'] = {k: Path(v) for (k, v) in d['crates'].items()}
    return d

def read_master_user_config(fail):
    root = search_for_root(fail)
    try:
        with open(root / MASTER_USER_CFG_PATH) as f:
            d = toml.load(f)
        return UserConfig(d)
    except FileNotFoundError:
        return UserConfig({'config': {}})

def get_internal_crates_and_root_rel_paths(fail):
    # There used to be logic in here that branched on whether each
    # value in [crates] was a str or a dict... but I think there is
    # already other code that assumes the values are all paths?
    return read_master_config(fail)['crates']

def get_internal_crate_names(fail):
    return set(get_internal_crates_and_root_rel_paths(fail))

def get_root_package(fail):
    return read_master_config(fail)['root']

def crate_name_from_path(path):
    with open(Path(path) / "Cargo.toml") as f:
        return toml.load(f)['package']['name']

def is_root(path):
    return (Path(path) / MASTER_CFG_PATH).exists()

def search_for_root(fail):
    d = Path('.')
    for _ in range(20):
        if is_root(d):
            return d.resolve()
        d = d / '..'
    fail('Cannot find workspace root!')

# set a path for one of our crates, by plaintext search
def master_config_textual_add(lines, line, fail):
    lines = list(lines)
    stripped = [x.strip() for x in lines]
    try: i = stripped.index(INSERTION_POINT_TEXT)
    except ValueError:
        fail(f'''
Failed to find the new crate insertion point in '{MASTER_CFG_PATH}'
It should look like the following:
    {INSERTION_POINT_TEXT}
'''[:-1])
        assert False, "unreachable"

    lines.insert(i, line)
    return lines

# set a path for one of our crates, by plaintext search.
# 'path = None' deletes
def master_config_textual_set_path(lines, name, path, fail):
    lines = list(lines)
    name = canonicalize_crate(name)

    for (i,line) in enumerate(lines):
        if canonicalize_crate(line.strip()).startswith(name):
            # expect exactly two, paired quotes
            quotes = list(find_all_indices_of_any("\"'", line))
            if not (len(quotes) == 2 and line[quotes[0]] == line[quotes[1]]):
                fail(f"""
{MASTER_CFG_PATH}:{i}: This line looks funny, not sure how to edit it.
It should ideally look like:
    {name} = 'current/path/to/{name}'
But at least make sure there are exactly two quotes of the same style.
"""[1:])

            if path is None:
                del lines[i]
            else:
                lines[i] = f'{lines[i][:quotes[0]+1]}{path}{lines[i][quotes[1]:]}'

            return lines
    else: # pylint: disable=useless-else-on-loop
        fail(f"{MASTER_CFG_PATH}: Failed to find line for {name}.")

#------------

# FIXME this is waaaaaay too application-specific.
# Maybe .crates.d could have some simplistic plugin files or something for crap like this.
def get_binary_shim_pairs():
    with open('src/tasks/entry_points.rs') as f:
        lines = list(f)

    pairs = []
    for cur, nxt in zip(lines, lines[1:]):
        heuristic = "CRATES" # for better debugging
        cur = cur.strip()
        nxt = nxt.strip()
        if heuristic in cur:
            prefix = "// %% CRATES: binary: "
            suffix = " %%"
            assert cur.startswith(prefix)
            assert cur.endswith(suffix)
            bin = cur[len(prefix):-len(suffix)]

            prefix = "pub fn "
            suffix = "() {"
            assert nxt.startswith(prefix)
            assert nxt.endswith(suffix)
            func = nxt[len(prefix):-len(suffix)]

            pairs.append((bin, func))

    return sorted(pairs)

def make_binary_shims(pairs):
    shims_dir = Path("src/binary-shims")
    shims_dir.mkdir(exist_ok = True)

    for (bin, func) in pairs:
        with open(shims_dir / f"{bin}.rs", mode='w') as f:
            print(f"""\
extern crate rsp2_tasks;

fn main() {{
    ::rsp2_tasks::entry_points::{func}();
}}
""", end='', file=f)


def macro_subst_for_binary_shims(pairs):
    def gen(**_ignored):
        entries = []
        for (bin, _func) in pairs:
            lines = [
                f"[[bin]]\n",
                f'name = "{bin}"\n',
                f'path = "src/binary-shims/{bin}.rs"\n',
            ]
            entries.append(''.join(lines))
        return '\n'.join(entries)
    return gen

def macro_subst_for_nightly_feature(lookup_get, crates, fail):
    root_name = get_root_package(fail)
    def gen(*, cur_name, **_ignored):
        deps = []
        if cur_name == root_name:
            deps = sorted([name for name in crates if name != root_name])
        else:
            deps = []
            with open(root_rel_src_toml_path(cur_name)) as f:
                for line in f:
                    macro = line_as_macro(line)
                    if macro is None:
                        continue

                    (kind, _func) = lookup_get(macro)
                    if kind is KIND_INTERNAL_DEP:
                        deps.append(macro)

        def recursive_feature_line(feature, base_list=()):
            toml_strs = [f'"{f}"' for f in base_list]
            toml_strs += sorted([f'"{d}/{feature}"' for d in deps])
            toml_list = '[' + ', '.join(toml_strs) + ']'
            return f"{feature} = {toml_list}"
        nightly = recursive_feature_line("nightly", ['beta'])
        beta = recursive_feature_line("beta")
        return f'{nightly}\n{beta}'
    return gen

#------------

def root_rel_src_toml_path(crate_name):
    return Path(CARGO_TOMLS_DIR) / f'{crate_name}.Cargo.toml'

# Variant of open(path, 'w') that writes to a temp file,
# then overwrites the requested file only once the context manager
# is exited without an exception
@contextmanager
def open_tmp(path, mode='w'):
    import tempfile
    with tempfile.NamedTemporaryFile(mode=mode, delete=False) as f:
        try: yield f
        except:
            # THIS NEVER HAPPENED
            os.unlink(f.name)
            raise
        f.flush()

    # exiting the 'with' closes (but doesn't delete) the temp file

    # Make the new file official.
    #
    # Writing Cargo.toml seems to cause rebuilds of any crate
    # that has a build.rs, so try to avoid it if we can.
    replace_if_different(path, f.name)

@contextmanager
def pushd(path):
    old = os.path.abspath('.')
    os.chdir(path)
    try: yield None
    finally: os.chdir(old)

def replace_if_different(current, candidate):
    import shutil
    with open(current) as f:
        a = f.read()
    with open(candidate) as f:
        b = f.read()

    if a != b:
        shutil.move(candidate, current)
    else:
        os.unlink(candidate)

def find_all_indices_of_any(needles, haystack):
    needles = set(needles)
    for (i, x) in enumerate(haystack):
        if x in needles:
            yield i

def rm_rf(path):
    import shutil
    path = Path(path)
    try:
        # note: cannot call rmtree on a symlink because lolidunno
        if path.is_dir() and not path.is_symlink():
            shutil.rmtree(path)
        else:
            unlink(path)
    except FileNotFoundError:
        pass

iife = lambda f: f()

#------------

# CLion thinks these functions can't accept pathlib.Path.
def unlink(path):
    return os.unlink(str(path))
def symlink(a, b):
    return os.symlink(str(a), str(b))
def listdir(path):
    return os.listdir(str(path))
def readlink(path):
    return os.readlink(str(path))

#------------

if __name__ == '__main__':
    main()
