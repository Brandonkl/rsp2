#!/usr/bin/env python3

# This file is licensed under WTFPL 2.0.
# I honestly do not care what you do with it.

import pytoml as toml
import os

# See crates.d/crates.toml for what this script is all about.
#
# For TOML file modification, this script relies mostly on plain
# text searching and substitution; this is partly because I doubt
# there's any good round-trip parsers for TOML in python,
# and I hate to destroy comments and other fine details.

COMMAND_GEN = object()
COMMAND_NEW = object()

MASTER_CFG_PATH = 'crates.d/crates.toml'
CARGO_TOMLS_DIR = 'crates.d'
# something long enough for people to grep and find this script
INSERTION_POINT_TEXT = "#!!INSERTION POINT FOR NEW CRATES!!#"

def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description='manage Cargo.tomls in sp2')

    def no_command(*junk):
        parser.error("no subcommand specified")
    parser.set_defaults(cmd=no_command)

    subs = parser.add_subparsers(title='subcommands')
    sub = subs.add_parser('gen',
        description=f'Regenerate Cargo.tomls from the source files in ./{CARGO_TOMLS_DIR}')
    sub.set_defaults(cmd=gen__main)

    sub = subs.add_parser('new')
    sub.add_argument('CRATENAME')
    sub.add_argument('DIR')
    sub.set_defaults(cmd=new__main)

    args = parser.parse_args()
    args.cmd(parser, args)

#------------

def gen__main(parser, args):
    with open(MASTER_CFG_PATH) as f:
        data = toml.load(f)
        crates = data.pop('crates')
        preferred_versions = data.pop('preferred-versions')

    # catch some dumb user errors before we get too committed
    for (name, path) in crates.items():
        if not os.path.isdir(path):
            parser.error('[crates."{}"]: "{}": no such directory'.format(name, path))

        src = src_toml_path(name)
        if not os.path.isfile(src):
            parser.error('{}: no such file'.format(src))

    # callbacks that generate substitutions for the line !!some-crate-name,
    # which accept the current Cargo.toml's directory as an argument
    def gen_constant(s):
        return lambda _: s

    def gen_relpath_to(crate_name, dep_dir):
        from os.path import normpath, relpath
        def inner(d):
            rel = normpath(relpath(dep_dir, start=d))
            return f'{crate_name} = {{ path = "{rel}" }}'
        return inner

    def gen_members_as_pathdeps(_):
        lines = []
        for (name, path) in crates.items():
            if path != ".":
                lines.append(f'{name} = {{ path = "{path}" }}')
        return '\n'.join(lines)

    # build a dash-insensitive lookup table of callbacks
    lookup_d = {
        'WORKSPACE-MEMBERS-AS-PATH-DEPS': gen_members_as_pathdeps,
    }
    lookup_put = lambda k, v: lookup_d.__setitem__(k.replace('_', '-'), v)
    lookup_get = lambda k: lookup_d.get(k.replace('_', '-'))

    for (name, path) in crates.items():
        lookup_put(name, gen_relpath_to(name, path))
    for (name, version) in preferred_versions.items():
        lookup_put(name, gen_constant('{} = "{}"'.format(name, version)))

    # generate modified forms of each Cargo.toml
    for (name, path) in crates.items():
        src_path = os.path.join(src_toml_path(name))
        dest_path = os.path.join(path, 'Cargo.toml')

        with open(src_path) as f:
            lines = list(f)

        with open(dest_path, 'w') as f:
            write = lambda *args: print(*args, file=f)
            write("# DO NOT EDIT THIS FILE BY HAND!!")
            write("# It has been autogenerated from", src_path)
            write("#")
            write("# To update it, run './crates gen' in the workspace root")
            write()

            for (i, line) in enumerate(lines):
                line = line.rstrip('\n')

                macro = line_as_macro(line)
                if macro is None:
                    write(line)
                    continue

                func = lookup_get(macro)
                if func is None:
                    s = f"{src_path}:{i}: unknown macro: {format_macro(macro)}"
                    parser.error(s)

                write(func(path))

# If a line is of the form "  !!macro-name  ", get "macro-name", else None
def line_as_macro(line):
    line = line.strip()
    if line[:2] == "!!":
        return line[2:]
    return None

def format_macro(name):
    return '!!' + name

#------------

CARGO_TOML_TEMPLATE = '''
[package]
name = "{}"
version = "0.1.0"
authors = ["Michael Lamparski <diagonaldevice@gmail.com>"]

[lib]
path = "lib.rs"

[dependencies]
'''[1:]

def new__main(parser, args):
    name = args.CRATENAME
    path = args.DIR
    if os.path.exists(path):
        parser.error(f'"{path}": path already exists')
    if os.path.exists(src_toml_path(name)):
        parser.error(f'crate "{name}" already exists')

    # Insert a line to crates.toml without destroying formatting
    with open(MASTER_CFG_PATH) as f:
        lines = list(f)

    stripped = [x.strip() for x in lines]
    try: i = stripped.index(INSERTION_POINT_TEXT)
    except: parser.error(f'''
Failed to find the new crate insertion point in '{MASTER_CFG_PATH}'
It should look like the following:
    {INSERTION_POINT_TEXT}
'''[:-1])

    lines.insert(i, f'{name} = "{path}"\n')

    # don't overwrite the original just yet, in case of errors
    with open(MASTER_CFG_PATH + '.tmp', 'w') as f:
        f.writelines(lines)

    # make the directory
    os.mkdir(path)
    with open(src_toml_path(name), 'w') as f:
        f.write(CARGO_TOML_TEMPLATE.format(name))
    with open(os.path.join(path, "Cargo.toml"), 'w') as f:
        f.write(CARGO_TOML_TEMPLATE.format(name))
    with open(os.path.join(path, 'lib.rs'), 'w') as f:
        f.write('''
#[test]
fn it_works() { }
'''[1:])

    # commit our changes to the main config
    import shutil
    shutil.move(MASTER_CFG_PATH + '.tmp', MASTER_CFG_PATH)


#------------

def src_toml_path(crate_name):
    return os.path.join(CARGO_TOMLS_DIR, f'{crate_name}.Cargo.toml')

iife = lambda f: f()

#------------

if __name__ == '__main__':
    main()
