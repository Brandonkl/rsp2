#!/usr/bin/env python3

# This file is licensed under WTFPL 2.0.
# I honestly do not care what you do with it.

from contextlib import contextmanager
from pathlib import Path
import os
import sys

import pytoml as toml

# See crates.d/crates.toml for what this script is all about.
#
# For TOML file modification, this script relies mostly on plain
# text searching and substitution; this is partly because I doubt
# there's any good round-trip parsers for TOML in python,
# and I hate to destroy comments and other fine details.

CARGO_TOMLS_DIR = Path('crates.d')
MASTER_CFG_PATH = Path('crates.d/crates.toml')
# something long enough for people to grep and find this script
INSERTION_POINT_TEXT = "#!!INSERTION POINT FOR NEW CRATES!!#"

def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description='manage Cargo.tomls in sp2')

    def no_command(*_junk):
        parser.error("no subcommand specified")
    parser.set_defaults(klass=no_command)

    subs = parser.add_subparsers(title='subcommands')

    for klass in ALL_COMMANDS:
        sub = subs.add_parser(klass.cmd, **klass.parser_kw)
        sub.set_defaults(klass=klass)
        klass.configure(sub)

    args = parser.parse_args()
    args.klass.run(parser, args)

ALL_COMMANDS = []
def register(klass):
    ALL_COMMANDS.append(klass)
    return klass

#------------

thru = lambda f: lambda g: lambda *a, **kw: f(g(*a, **kw))

#------------

@register
class Gen:
    cmd = 'gen'
    parser_kw = dict(
        description=f'Regenerate Cargo.tomls from the source files in {CARGO_TOMLS_DIR}',
    )

    @staticmethod
    def configure(_sub):
        pass

    @staticmethod
    def run(parser, _args):

        with pushd(search_for_root(parser.error)):
            data = read_master_config(parser.error)
            crates = data.pop('crates')
            preferred_versions = data.pop('preferred-versions')

            # catch some dumb user errors before we get too committed
            for (name, path) in crates.items():

                if not path.is_dir():
                    parser.error('[crates."{}"]: "{}": no such directory'.format(name, path))

                src = root_rel_src_toml_path(name)
                if not src.is_file():
                    parser.error('{}: no such file'.format(src))

            # callbacks that generate substitutions for the line !!some-crate-name,
            # which accept the current Cargo.toml's directory as an argument
            def gen_constant(s):
                return lambda _: s

            def gen_relpath_to(crate_name, dep_dir):
                def inner(d):
                    # Don't use Path for this because:
                    # - It has no normpath equivalent that doesn't follow links (wtf?)
                    # - Its relpath equivalent is too strict
                    rel = os.path.normpath(os.path.relpath(dep_dir, d))
                    return f'{crate_name} = {{ path = "{rel}" }}'
                return inner

            def gen_members_as_pathdeps(_):
                root = get_root_package(parser.error)
                lines = []
                for (name, path) in crates.items():
                    if name != root:
                        lines.append(f'{name} = {{ path = "{path}" }}')
                return '\n'.join(lines)

            # build a dash-insensitive lookup table of callbacks
            lookup_d = {
                'WORKSPACE-MEMBERS-AS-PATH-DEPS': gen_members_as_pathdeps,
            }
            lookup_put = lambda k, v: lookup_d.__setitem__(k.replace('_', '-'), v)
            lookup_get = lambda k: lookup_d.get(k.replace('_', '-'))

            for (name, path) in crates.items():
                lookup_put(name, gen_relpath_to(name, path))
            for (name, version) in preferred_versions.items():
                lookup_put(name, gen_constant('{} = {}'.format(name, inline_toml(version))))

            # Make all target directories symlinks to the root package's target,
            # to help reduce duplicate build artefacts even if we are not a
            # true workspace.
            #
            # Also link together configuration directories for subcrates.
            root_package_name = get_root_package(parser.error)

            ensure_not_symlink('target')
            (Path('.subcrate-cfg') / '.idea').mkdir(parents=True, exist_ok=True)
            (Path('.subcrate-cfg') / '.vscode').mkdir(parents=True, exist_ok=True)
            for (name, path) in crates.items():
                if name != root_package_name:
                    maybe_ensure_target_link('.', path)
                    maybe_ensure_target_link('.subcrate-cfg', path, filename='.idea')
                    maybe_ensure_target_link('.subcrate-cfg', path, filename='.vscode')

            # generate modified forms of each Cargo.toml
            for (name, path) in crates.items():

                src_path = Path(root_rel_src_toml_path(name))
                dest_path = path / 'Cargo.toml'
                with open(src_path) as f:
                    lines = list(f)

                with open(dest_path, 'w') as f:
                    write = lambda *args: print(*args, file=f)
                    write("# DO NOT EDIT THIS FILE BY HAND!!")
                    write("# It has been autogenerated from", src_path)
                    write("#")
                    write("# To update it, run './crates gen' in the workspace root")
                    write()

                    for (i, line) in enumerate(lines):
                        line = line.rstrip('\n')

                        macro = line_as_macro(line)
                        if macro is None:
                            write(line)
                            continue

                        func = lookup_get(macro)
                        if func is None:
                            s = f"{src_path}:{i}: unknown macro: {format_macro(macro)}"
                            parser.error(s)

                        write(func(path))

# a makeshift toml.dumps that uses inline tables
def inline_toml(x):
    if isinstance(x, dict):
        items = ', '.join(f'{k} = {inline_toml(v)}' for (k, v) in x.items())
        return f'{{ {items} }} '
    elif isinstance(x, list):
        items = ', '.join(inline_toml(v) for v in x)
        return f'[{items}]'
    # types that only have an inline representation
    elif isinstance(x, (str, float, int, bool)):
        # I'm not 100% sure if python str() makes a valid toml str
        # so dumb dumb hack dumb hack hack dumb dumb dumb
        s = toml.dumps({'a': x}).strip()
        assert s.startswith('a')
        s = s[1:].strip()
        assert s.startswith('=')
        s = s[1:].strip()
        return s
    else:
        raise TypeError(x)

# If a line is of the form "  !!macro-name  ", get "macro-name", else None
def line_as_macro(line):
    line = line.strip()
    if line[:2] == "!!":
        return line[2:]
    return None

def format_macro(name):
    return '!!' + name

# tries to have a crate's target symlink back to the root crate's target,
# but may fail. (no big deal)
#
# The logic here was really intended for just the target directory,
#  but 'name' can be specified to reuse this for files where the logic
#  for target is probably good enough
# (the theme is: "a symlink to a directory that an IDE is very likely
#                 to attempt to regenerate the moment it vanishes")
def maybe_ensure_target_link(root_path, crate_path, filename='target'):
    path = Path(crate_path) / filename
    dest = os.path.relpath(Path(root_path) / filename, crate_path)

    # don't remove existing links unless we have to.
    if path.is_symlink() and os.readlink(path) == str(dest):
        return

    # As soon as we destroy the existing contents, we are in a race
    #  against the RLS to recreate the directory the way WE want it.
    rm_rf(path)

    # gogogogogogogogo!!!!!!
    try: os.symlink(dest, path)
    except FileExistsError:
        # Damn, the RLS probably beat us.
        # Let it win; maybe we'll have better luck next time.
        pass

def ensure_not_symlink(path):
    if os.path.islink(path):
        os.unlink(path)

#------------

CARGO_TOML_TEMPLATE = '''
[package]
name = "{}"
version = "0.1.0"
authors = ["Michael Lamparski <diagonaldevice@gmail.com>"]

[lib]
path = "lib.rs"

[dependencies]
'''[1:]

@register
class New:
    cmd = 'new'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATENAME')
        sub.add_argument('DIR')

    @staticmethod
    def run(parser, args):

        if not is_root('.'):
            # (I'm too lazy to work out the correct relative paths
            # to be written to crates.toml)
            parser.error("The 'new' subcommand must be run from the root.")

        name = args.CRATENAME
        path = Path(args.DIR)

        if path.exists():
            parser.error(f'"{path}": path already exists')
        if (path / root_rel_src_toml_path(name)).exists():
            parser.error(f'crate "{name}" already exists')

        # Insert a line to crates.toml without destroying formatting
        # (do this now for earlier exits on error)
        with open(MASTER_CFG_PATH) as f:
            lines = list(f)
        lines = master_config_textual_add(lines, f'{name} = "{path}"\n', fail=parser.error)

        # make the directory
        path.mkdir()
        with open(root_rel_src_toml_path(name), 'w') as f:
            f.write(CARGO_TOML_TEMPLATE.format(name))
        with open(path / "Cargo.toml", 'w') as f:
            f.write(CARGO_TOML_TEMPLATE.format(name))
        with open(path / 'lib.rs', 'w') as f:
            f.write('''
#[test]
fn it_works() { }
'''[1:])

        with open_tmp(MASTER_CFG_PATH) as f:
            f.writelines(lines)

        # regenerate
        Gen.run(parser, None)

#------------

@register
class Mv:
    cmd = 'mv'
    parser_kw = {}

    @staticmethod
    def configure(sub):
        sub.add_argument('CURDIR')
        sub.add_argument('DESTDIR')

    @staticmethod
    def run(parser, args):

        if not is_root('.'):
            # (I'm too lazy to work out the correct relative paths
            # to be written to crates.toml)
            parser.error("The 'mv' subcommand must be run from the root.")

        curdir = Path(args.CURDIR)
        destdir = Path(args.DESTDIR)
        if destdir.exists():
            parser.error(f'"{destdir}": path already exists')
        if not curdir.exists():
            parser.error(f'"{curdir}": path does not exist')

        crate = crate_name_from_path(curdir)

        # Edit the line in crates.toml without destroying formatting
        # (do this now for earlier exits on error)
        with open(MASTER_CFG_PATH) as f:
            lines = list(f)
        lines = master_config_textual_set_path(lines, crate, destdir, fail=parser.error)

        # move the directory
        curdir.rename(destdir)

        with open_tmp(MASTER_CFG_PATH) as f:
            f.writelines(lines)

        # regenerate
        Gen.run(parser, None)

#------------

@register
class Test:
    cmd = 'test'
    parser_kw = dict(
        description=
            "Replacement for 'cargo test --all' now that this isn't a workspace."
            " You won't believe how it works."
    )

    @staticmethod
    def configure(sub):
        pass

    @staticmethod
    def run(parser, _args):
        from subprocess import Popen

        # regenerate
        Gen.run(parser, None)

        with pushd(search_for_root(parser.error)):
            # Create a replica that looks exactly like our project,
            #  except that it truly is a workspace.
            TEST_ROOT = '.secret-test-dir'
            ensure_test_replica_exists(TEST_ROOT)

            code = Popen(['cargo', 'test', '--all'], cwd=TEST_ROOT).wait()
            if code:
                sys.exit(code)

            # keep TEST_ROOT around for build artefacts

def ensure_test_replica_exists(test_root):
    import shutil
    test_root = Path(test_root)

    if not test_root.exists():
        test_root.mkdir()

    for path in map(Path, ['src', 'tests', 'examples']):
        test_path = test_root / path
        if not test_path.exists():
            test_path.symlink_to('..' / path)

    test_cargo = test_root / 'Cargo.toml'
    shutil.copyfile('Cargo.toml', test_cargo)
    with open(test_cargo, 'a') as f:
        f.write('\n')
        f.write('[workspace]\n')

#------------

@register
class Dot:
    cmd = 'dot'
    parser_kw = dict(
        description="Show dependency graph."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('--root', action='store_true', dest='root')
        sub.add_argument('--no-root', action='store_false', dest='root')
        sub.set_defaults(root=False)

        sub.add_argument('--no-leaves', action='store_false', dest='leaves')
        sub.add_argument('--leaves', action='store_true', dest='leaves')
        sub.set_defaults(leaves=True)

    @staticmethod
    def run(parser, args):
        import matplotlib.pyplot as plt
        import networkx as nx
        from networkx.drawing.nx_pydot import write_dot

        # regenerate
        Gen.run(parser, None)

        with pushd(search_for_root(parser.error)):
            g = nx.DiGraph()
            crates = get_internal_crates_and_root_rel_paths(parser.error)
            for (crate, path) in crates.items():
                with open(path / 'Cargo.toml') as f:
                    d = toml.load(f)
                for dep in d['dependencies']:
                    if dep in crates:
                        g.add_edge(crate, dep)

            if not args.root:
                g.remove_node(get_root_package(parser.error))

            if not args.leaves:
                leaves = [node for node in g if g.out_degree(node) == 0]
                for node in leaves:
                    g.remove_node(node)

            write_dot(g, sys.stdout)
            plt.show()

#------------

@register
class Edit:
    cmd = 'edit'
    parser_kw = dict(
        description="Edit a crate's Cargo.toml."
    )

    @staticmethod
    def configure(sub):
        sub.add_argument('CRATE_OR_PATH', default='.')

    @staticmethod
    def run(parser, args):
        import subprocess

        if args.CRATE_OR_PATH in get_internal_crate_names(parser.error):
            crate = args.CRATE_OR_PATH
        else:
            crate = crate_name_from_path(args.CRATE_OR_PATH)

        root = search_for_root(parser.error)
        toml_path = root / root_rel_src_toml_path(crate)

        editor = os.environ.get('EDITOR') or 'vim'
        if subprocess.run([editor, toml_path]).returncode != 0:
            print(f"Failed to edit '{toml_path}'!")
            sys.exit(1)

        # regenerate
        Gen.run(parser, None)


#------------

def read_master_config(fail):
    root = search_for_root(fail)
    with open(root / MASTER_CFG_PATH) as f:
        d = toml.load(f)
    d['crates'] = {k: Path(v) for (k, v) in d['crates'].items()}
    return d

def get_internal_crates_and_root_rel_paths(fail):
    # There used to be logic in here that branched on whether each
    # value in [crates] was a str or a dict... but I think there is
    # already other code that assumes the values are all paths?
    return read_master_config(fail)['crates']

def get_internal_crate_names(fail):
    return set(get_internal_crates_and_root_rel_paths(fail))

def get_root_package(fail):
    return read_master_config(fail)['root']

def crate_name_from_path(path):
    with open(Path(path) / "Cargo.toml") as f:
        return toml.load(f)['package']['name']

def is_root(path):
    return (Path(path) / MASTER_CFG_PATH).exists()

def search_for_root(fail):
    d = Path('.')
    for _ in range(20):
        if is_root(d):
            return d.resolve()
        d = d / '..'
    fail('Cannot find workspace root!')

# set a path for one of our crates, by plaintext search
def master_config_textual_add(lines, line, fail):
    lines = list(lines)
    stripped = [x.strip() for x in lines]
    try: i = stripped.index(INSERTION_POINT_TEXT)
    except: fail(f'''
Failed to find the new crate insertion point in '{MASTER_CFG_PATH}'
It should look like the following:
    {INSERTION_POINT_TEXT}
'''[:-1])

    lines.insert(i, line)
    return lines

# set a path for one of our crates, by plaintext search
def master_config_textual_set_path(lines, name, path, fail):
    lines = list(lines)
    name = name.replace('_', '-')

    for (i,line) in enumerate(lines):
        if line.strip().replace('_', '-').startswith(name):
            # expect exactly two, paired quotes
            quotes = list(find_all_indices_of_any("\"'", line))
            if not (len(quotes) == 2 and line[quotes[0]] == line[quotes[1]]):
                fail(f"""
{MASTER_CFG_PATH}:{i}: This line looks funny, not sure how to edit it.
It should ideally look like:
    {name} = 'current/path/to/{name}'
But at least make sure there are exactly two quotes of the same style.
"""[1:])

            lines[i] = f'{lines[i][:quotes[0]+1]}{path}{lines[i][quotes[1]:]}'
            return lines

    fail(f"{MASTER_CFG_PATH}: Failed to find line for {name}.")

#------------

def root_rel_src_toml_path(crate_name):
    return Path(CARGO_TOMLS_DIR) / f'{crate_name}.Cargo.toml'

# Variant of open(path, 'w') that writes to a temp file,
# then overwrites the requested file only once the context manager
# is exited without an exception
@contextmanager
def open_tmp(path, mode='w'):
    import tempfile
    with tempfile.NamedTemporaryFile(mode=mode, delete=False) as f:
        try: yield f
        except:
            # THIS NEVER HAPPENED
            os.unlink(f.name)
            raise
        f.flush()

    # exiting the 'with' closes (but doesn't delete) the temp file

    # Make the new file official.
    #
    # Writing Cargo.toml seems to cause rebuilds of any crate
    # that has a build.rs, so try to avoid it if we can.
    replace_if_different(path, f.name)

@contextmanager
def pushd(path):
    old = os.path.abspath('.')
    os.chdir(path)
    try: yield None
    finally: os.chdir(old)

def replace_if_different(current, candidate):
    import shutil
    with open(current) as f:
        a = f.read()
    with open(candidate) as f:
        b = f.read()

    if a != b:
        shutil.move(candidate, current)
    else:
        os.unlink(candidate)

def find_all_indices_of_any(needles, haystack):
    needles = set(needles)
    for (i, x) in enumerate(haystack):
        if x in needles:
            yield i

def rm_rf(path):
    import shutil
    path = Path(path)
    try:
        # note: cannot call rmtree on a symlink because lolidunno
        if path.is_dir() and not path.is_symlink():
            shutil.rmtree(path)
        else:
            os.unlink(path)
    except FileNotFoundError:
        pass

iife = lambda f: f()

#------------

if __name__ == '__main__':
    main()
