//! Computes raman intensities of gamma eigenkets using
//! a bond polarizability model.
//!
//! Adapted from the sp2 code.

use ::Result;
use ::util::zip_eq;
use ::types::basis::Basis3;
use ::math::bonds::{Bond, Bonds};
use ::enum_map::EnumMap;
use ::rsp2_array_types::{dot, mat, V3, M33};
use ::rsp2_structure::{Element};

pub struct PolConstant {
    /// `a_par  -   a_perp`
    pub c1: f64,
    /// `a'_par -   a'_perp`
    pub c2: f64,
    /// `a'_par + 2 a'_perp`
    pub c3: f64,
    /// maximum bond length
    pub max_len: f64,
}

// NOTE: there are also constant factors out front based on input light frequency
//       and stuff, so this only gives proportional intensities
fn raman_prefactor(
    frequency: f64,
    temperature: f64,
) -> f64 {
    assert_ne!(frequency, 0.0);

    // (hbar / k_b) in [K] per [cm-1]
    let hk = 0.22898852319;

    let bose_occupation = 1.0 + 1.0 / f64::exp_m1(hk * frequency / temperature);

    bose_occupation / frequency
}

#[derive(EnumMap)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum BondType { CC, CH, HH }

impl BondType {
    fn from_elements(a: Element, b: Element) -> Result<BondType> {
        use rsp2_structure::consts::{CARBON, HYDROGEN};
        Ok(match (a, b) {
            (CARBON, CARBON) => BondType::CC,
            (CARBON, HYDROGEN) => BondType::CH,
            (HYDROGEN, CARBON) => BondType::CH,
            (HYDROGEN, HYDROGEN) => BondType::HH,
            _ => bail!{
                "No polarization constants specified for bonds between {} and {}",
                a.symbol(), b.symbol(),
            },
        })
    }
}

pub type PolConstants = EnumMap<BondType, PolConstant>;
#[allow(bad_style)]
pub fn default_CH_pol_constants() -> PolConstants {
    enum_map!{
        BondType::CC => PolConstant {
            c1: 0.32, c2: 2.60, c3: 7.55,
            max_len: 1.6,
        },
        BondType::CH => PolConstant {
            c1: 0.32, c2: 2.60, c3: 7.55,
            max_len: 1.3,
        },
        // FIXME: ??? why is this like this?
        // (this is just copied from sp2)
        BondType::HH => PolConstant {
            c1: 0.0, c2: 0.0, c3: 0.0,
            max_len: 1.1,
        },
    }
}

fn raman_intensity(
    frequency: f64,
    temperature: f64,
    incident: &V3,
    scattered: &V3,
    eigenvector: &[V3],
    masses: &[f64],
    bonds: &Bonds,
    types: &[Element],
    pol_constants: &PolConstants,
) -> Result<f64> {
    let tensor = &raman_tensor(
        eigenvector,
        masses,
        bonds,
        types,
        pol_constants,
    )?;

    let prefactor = raman_prefactor(frequency, temperature);
    let sum = dot(incident, &(tensor * scattered));

    Ok(prefactor * (sum * sum))
}

fn raman_intensity_avg(
    backscatter: bool,
    frequency: f64,
    temperature: f64,
    eigenvector: &[V3],
    masses: &[f64],
    bonds: &Bonds,
    types: &[Element],
    pol_constants: &PolConstants,
) -> Result<f64> {
    let tensor = &raman_tensor(
        eigenvector,
        masses,
        bonds,
        types,
        pol_constants,
    )?;

    // there was probably an easier way to do this, or a simple proof, given
    // the extremely simple answer
    //
    // random unit vectors in 3D can be generated by generating gaussian x, y, z
    //     v = (x, y, z) / sqrt(x^2 + y^2 + z^2)
    //       = (cos(phi) sin(theta), sin(phi) sin(theta), cos(theta))
    //
    // since we want the average of v^T (polarization tensor) v, we need to
    // find the expectation values for the matrix
    //
    //     1       (x1x2 a + x1y2 b + x1z2 c +
    // --------- *  y1x2 d + y1y2 e + y1z2 f +
    // (r1 r2)^2    z1x2 g + z1y2 h + z1z2 i)^2
    //
    // which ends up looking like the integral of
    //  = (elem)  e^(-(r1^2 + r2^2)/2) / (r1 r2)^2
    //  = (1/sqrt(2 pi))^6 * (elem / (r1 r2)^2) *  e^(-(r1^2 + r2^2)/2)
    //  = (1/sqrt(2 pi))^6 * g(theta1, phi1, theta2, phi2) * f(r1, r2)
    //
    // using [integral 0 to inf of (r^2 e^(-r^2/2) dr) = sqrt(pi / 2)] what
    // we have left is the integral of
    //  = 1 / (16 pi^2) (elem / (r1 r2)^2)
    //
    // so essentially all we need to integrate is
    //    [cos^2(phi) sin^2(theta), xx
    //     sin^2(phi) sin^2(theta), yy
    //     cos(phi) sin(phi) sin^2(theta), xy
    //     cos^2(theta), zz
    //     sin(phi) cos(theta) sin(theta), zy
    //     cos(phi) cos(theta) sin(theta)] zx
    //      * sin(theta) dtheta dphi
    //
    //     xx = 4 pi / 3
    //     yy = 4 pi / 3
    //     zz = 4 pi / 3
    //
    //     yx = 0
    //     yz = 0
    //     xz = 0
    //
    //     = [4/3 pi, 4/3 pi, 4/3 pi]
    //
    // back to the original equation we get
    //  = (4/3 pi)^2 / (16 pi^2)
    //  = 1 / 9
    //
    // for 2D (backscattering) its just:
    //  = 1 / (4 pi^2) (pi^2)
    //  = 1 / 4
    //
    let prefactor = raman_prefactor(frequency, temperature);

    let lim = if backscatter { 2 } else { 3 };
    let mut sum = 0.0;
    for i in 0..lim {
        for j in 0..lim {
            sum += tensor[i][j] * tensor[i][j];
        }
    }

    match backscatter {
        true => sum /= 4.0,
        false => sum /= 9.0,
    }

    Ok(prefactor * sum)
}

/// NOTE: Matrix is column-based.
fn raman_tensor(
    eigenvector: &[V3],
    masses: &[f64],
    bonds: &Bonds,
    types: &[Element],
    pol_constants: &PolConstants,
) -> Result<M33> {
    // kronecker delta value
    let kdelta = <M33>::eye();

    let mut tensor = M33::zero();
    for Bond { from, to, cart_vector: bond_vector } in bonds {
        let bond_type = BondType::from_elements(types[from], types[to])?;

        // phonon eigenvector for this atom, need to mass normalize
        let eig: V3 = eigenvector[from] / f64::sqrt(masses[from]);

        // unit bond vector and length, used later
        let distance: f64 = bond_vector.norm();
        let rhat: V3 = bond_vector / distance;

        // ignore bonds which have no corresponding polarization constants
        // specified in the input map
        let pc = &pol_constants[bond_type];

        // check if bond is actually valid (via length)
        if distance > pc.max_len {
            warn_once!("Bond list contains a bond that is too long! (ignoring it)");
            continue;
        }

        let const_one  = pc.c1; // `a_par  -   a_perp`
        let dconst_one = pc.c2; // `a'_par -   a'_perp`
        let dconst_two = pc.c3; // `a'_par + 2 a'_perp`

        // FIXME
        tensor += &mat::from_fn(|r, c| {
            // FIXME wtf is this
            //       this is just some matrix sum, right?
            dot(&rhat, &eig) * (
                (dconst_two / 3.0) * kdelta[r][c]
                    + dconst_one * (rhat[r] * rhat[c] - kdelta[r][c] / 3.0)
            ) + (const_one / distance) * (
                (rhat[r] * eig[c] + rhat[c] * eig[r])
                    - 2.0 * rhat[r] * rhat[c] * dot(&rhat, &eig)
            )
        });
    } // for Bond { ... } in bonds
    Ok(tensor)
}

/// Quick little struct to simulate named arguments
pub struct Input<'a> {
    pub light_polarization: &'a LightPolarization,
    pub temperature: f64,
    pub ev_frequencies: &'a [f64],
    pub ev_eigenvectors: &'a Basis3,
    pub atom_elements: &'a [Element],
    pub atom_masses: &'a [f64],
    pub bonds: &'a Bonds,
}

impl<'a> Input<'a> {
    pub fn compute_ev_raman_intensities(self) -> Result<Vec<f64>> {
        let Input {
            light_polarization, ev_frequencies, ev_eigenvectors,
            temperature, atom_elements, atom_masses, bonds,
        } = self;

        let pol_constants = default_CH_pol_constants();
        let result = zip_eq(ev_frequencies, &ev_eigenvectors.0).map(|(&frequency, eigs)| {
            let eigs = eigs.as_real_checked();
            match *light_polarization {
                LightPolarization::Polarized { ref incident, ref scattered } => {
                    return raman_intensity(
                        frequency, temperature,
                        incident, scattered,
                        eigs, atom_masses, bonds, atom_elements,
                        &pol_constants,
                    );
                },
                _ => {}
            };

            let backscatter = match *light_polarization {
                LightPolarization::Polarized { .. } => unreachable!(),
                LightPolarization::Average => false,
                LightPolarization::BackscatterZ => true,
            };
            raman_intensity_avg(
                backscatter,
                frequency, temperature,
                eigs, atom_masses, bonds, atom_elements,
                &pol_constants,
            )
        }).collect();

        // note that we don't normalize to unity, the user must
        result
    }
}

pub enum LightPolarization {
    // previously:  avg = false, backscatter = (ignored)
    Polarized {
        incident: V3,
        scattered: V3,
    },
    // previously:  avg = true, backscatter = false,
    Average,
    // previously:  avg = true, backscatter = true,
    BackscatterZ,
}
